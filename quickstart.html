<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title># Quickstart</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Seql</span> <span class="project-version">0.1.0</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="README.html"><div class="inner"><span># Introduction</span></div></a></li><li class="depth-1  current"><a href="quickstart.html"><div class="inner"><span># Quickstart</span></div></a></li><li class="depth-1 "><a href="sandbox.html"><div class="inner"><span># Sandbox set-up</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>seql</span></div></div></li><li class="depth-2 branch"><a href="seql.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2"><a href="seql.helpers.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>helpers</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h2><a href="#quickstart" name="quickstart"></a>Quickstart</h2>
<p>Let us assume the following - admitedly flawed - schema, for which we will add gradual support:</p>
<p><img src="https://i.imgur.com/DkBtyew.png" alt="schema" /></p>
<p>All the following examples can be reproduced in the <code>test/seql/readme_test.clj</code> integration test. To perform queries, an <em>environment</em> must be supplied, which consists of a schema, and a JDBC config.</p>
<p>For all schemas displayed below, we assume an env set up in the following manner:</p>
<pre><code class="clojure">(def env {:schema ... :jdbc your-database-config})
(require '[seql.core :refer [query mutate! add-listener!]])
(require '[seql.helpers :refer [schema ident field compound mutation
                                transform has-many condition entity]])
</code></pre>
<p>in <code>test/seql/fixtures.clj</code>, code is provided to experiment with an H2 database.</p>
<h3><a href="#queries-on-accounts" name="queries-on-accounts"></a>Queries on accounts</h3>
<p>At first, accounts need to be looked up. We can build a minimal schema:</p>
<pre><code class="clojure">(schema
  (entity :account
          (field :id (ident))
		  (field :name)
		  (field :state)))
</code></pre>
<p>Let’s unpack things here:</p>
<ul>
  <li>We give a name our entity, by default it will be assumed that the  SQL table it resides in is eponymous, when it is not the case, a  tuple of <code>[entity-name table-name]</code> can be provided</li>
  <li><em>Ident</em> fields are unique in the database and can be used to  retrieve a single record.</li>
</ul>
<p>With this, simple queries can be performed:</p>
<pre><code class="clojure">(query env :account [:account/name :account/state])

;; =&gt;

[#:account{:name "a0" :state "active"}
 #:account{:name "a1" :state "active"}
 #:account{:name "a2" :state "suspended"}]
</code></pre>
<p>Idents can also be looked up:</p>
<pre><code class="clojure">(query env [:account/id 0] [:account/name :account/state])

;; =&gt;

#:account{:name "a0" :state "active"}
</code></pre>
<p>Notice how the last query yielded a single value instead of a collection. It is expected that idents will yield at most a single value (as a corollary, idents should only be used for database fields which enforce this guarantee).</p>
<p>While this works, our schema can be improved in two ways:</p>
<ul>
  <li><code>name</code> is a good candidate for being an ident as well</li>
  <li>The <code>state</code> field would be better returned as a keyword if possible</li>
  <li>It could be interesting to be able to add conditions</li>
</ul>
<pre><code class="clojure">(schema
  (entity :account
    (field :id (ident))
    (field :name (ident))
    (field :state (transform :keyword))
    (condition :active :state :active)
    (condition :state)))
</code></pre>
<p>We can now perform the following query:</p>
<pre><code class="clojure">(query env [:account/name "a0"] [:account/name :account/state])

;; =&gt;

#:account{:name "a0" :state :active}

(query env :account [:account/name] [[:a/active]])

;; =&gt;

[#:account{:name "a0"}
 #:account{:name "a1"}]
 
 
(query env :account [:account/name] [[:a/state :suspended]])

;; =&gt;

[#:account{:name "a2"}]
</code></pre>
<h3><a href="#adding-a-relation" name="adding-a-relation"></a>Adding a relation</h3>
<p>For queries, <strong>seql</strong>’s strength lies in its ability to understand the way entities are tied together. Let’s start with a single relation before building larger nested trees. Since no assumption is made on schemas, the relations must specify foreign keys explictly:</p>
<pre><code class="clojure">(schema
   (entity :account
     (field :id (ident))
     (field :name (ident))
     (field :state (transform :keyword))
     (has-many :users [:id :user/account-id])
     (condition :active :state :active)
     (condition :state))

   (entity :user
     (field :id (ident))
     (field :name (ident))
     (field :email))
</code></pre>
<p>This will allow doing tree lookups, fetching arbitrary fields from the nested entity as well:</p>
<pre><code class="clojure">(query env
       :account
       [:account/name
        :account/state
        {:account/users [:user/name :user/email]}])
		
;; =&gt;

[#:account{:name  "a0"
           :state :active
           :users [#:user{:name "u0a0" :email "u0@a0"}
                   #:user{:name "u1a0" :email "u1@a0"}]}
 #:account{:name  "a1"
           :state :active
           :users [#:user{:name "u2a1" :email "u2@a1"}
                   #:user{:name "u3a1" :email "u3@a1"}]}
 #:account{:name "a2" :state :suspended :users []}]
</code></pre>
<h3><a href="#compounds-fields" name="compounds-fields"></a>Compounds fields</h3>
<p>SQL being less flexible than Clojure to represent value, compound fields can help build more appropriate representation of data. Compounds specify their source as a list of fields and a function which provided with these fields in order should yield a proper output value.</p>
<p>Looking at our schema, the <code>state</code> field of the <code>invoice</code> table can easily be converted into a boolean:</p>
<pre><code class="clojure">(schema
  (entity :invoice
          (field :id (ident))
          (field :state (transform :keyword))
          (field :total)
          (compound :paid? [state] (= state :paid))
          (condition :paid :state :paid)
          (condition :unpaid :state :unpaid)))
</code></pre>
<p>We can now assert that compounds are correctly realized:</p>
<pre><code>(query env :invoice [:invoice/total :invoice/paid?])

;; =&gt;

[#:invoice{:total 2, :paid? false}
 #:invoice{:total 2, :paid? true}
 #:invoice{:total 4, :paid? true}]
</code></pre>
<h3><a href="#summary-of-query-description" name="summary-of-query-description"></a>Summary of query description</h3>
<p>We’ve now covered full capabilities of the <em>query</em> part of the schema, were we saw that:</p>
<ul>
  <li>Each entity should at least have a <em>table</em>, list of <em>idents</em>, and  <em>fields</em>.</li>
  <li>To provide more idiomatic output, <em>transforms</em> allow field mangling.</li>
  <li>Beyond <em>idents</em>, <em>conditions</em> allow for building filters on  entities.</li>
  <li>To build arbitrarily nested entities, <em>relations</em> need to be used.</li>
  <li>For ad-hoc field buiding, <em>compounds</em> can receive database fields  and yield new values.</li>
</ul>
<p>With this in mind, here’s a complete schema for the above database schema:</p>
<pre><code class="clojure">(schema
 (entity :account
         (field :id          (ident))
         (field :name        (ident))
         (field :state       (transform :keyword))
         (has-many :users    [:id :user/account-id])
         (has-many :invoices [:id :invoice/account-id])

         (condition :active  :state :active)
         (condition :state))

 (entity :user
         (field :id          (ident))
         (field :name        (ident))
         (field :email))

 (entity :invoice
         (field :id          (ident))
         (field :state       (transform :keyword))
         (field :total)
         (compound :paid?    [state] (= state :paid))
         (has-many :lines    [:id :line/invoice-id])

         (condition :unpaid  :state :unpaid)
         (condition :paid    :state :paid))

 (entity [:line :invoiceline]
         (field :id          (ident))
         (field :product)
         (field :quantity)))
</code></pre>
<h3><a href="#mutations" name="mutations"></a>Mutations</h3>
<p>With querying sorted, mutations need to be expressed. Here, <strong>seql</strong> takes the approach of making mutations separate, explict, and validated. As with most other <strong>seql</strong> features, mutations are implemented with a key inside the entity description.</p>
<p>At its core, mutations expect two things:</p>
<ul>
  <li>A <strong>spec</strong> of their input</li>
  <li>A function of this input which must yield a proper <strong>honeysql</strong> query map, or collection  of <strong>honeysql</strong> query map to be performed in a transaction.</li>
</ul>
<pre><code>(s/def :account/name string?)
(s/def :account/state keyword?)
(s/def ::account (s/keys :req [:account/name :account/state]))


;; We can now modify the :account entity:

(entity :account
         (field :id          (ident))
         (field :name        (ident))
         (field :state       (transform :keyword))
         (has-many :users    [:id :user/account-id])
         (has-many :invoices [:id :invoice/account-id])

         (condition :active  :state :active)
         (condition :state)
		 
         (mutation :account/create ::account [params]
                   (-&gt; (h/insert-into :account)
                       (h/values [params])))

         (mutation :account/update ::account [{:keys [id] :as params}]
                   (-&gt; (h/update :account)
                       ;; values are fed unqualified
                       (h/sset (dissoc params :id))
                       (h/where [:= :id id]))))
</code></pre>
<p>Adding new accounts can now be done through <code>mutate!</code>:</p>
<pre><code class="clojure">(mutate! env :account/create {:account/name  "a3"
                              :account/state :active})
							  
(query env [:account/.name "a3"] [:account/state])

;; =&gt;

#:account{:state :active}
</code></pre>
<h3><a href="#listeners" name="listeners"></a>Listeners</h3>
<p>To provide for clean CQRS type workflows, listeners can be added to mutations. Each listener will subsequently be called on sucessful transactions with a map of:</p>
<ul>
  <li><code>:mutation</code>: the name of the mutation called</li>
  <li><code>:result</code>: the result of the transaction</li>
  <li><code>:params</code>: input parameters given to the mutation</li>
  <li><code>:metadata</code>: metadata supplied to the mutation, if any</li>
</ul>
<pre><code class="clojure">(def last-result (atom nil))

(defn store-result
  [details]
  (reset! last-result (select-keys details [:mutation :result])))

(let [env (add-listener! env store-result)]
   (mutate! env :account/create {:account/name "a4"
                                 :account/state :active}))
								 
@last-result

;; =&gt; {:result [1] :mutation :account/create}
</code></pre></div></div></div></body></html>